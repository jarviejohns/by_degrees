---
layout: page
title: Garbage Collection (Basics)
---

[Basics](https://jarviejohns.github.io/by_degrees/pages/distributed_computing/2017/01/19/garbage_collection.html) 
[Algorithms](https://jarviejohns.github.io/by_degrees/pages/distributed_computing/2017/01/19/gc_algos.html) 

Garbage collection - finding and throwing garbage. It is an automated memory reclamation process for JVM.

## What is Garbage?
The GC process tracks down all objects that are still used and marks everything else as garbage.

### Manual memory Management
Explicitly allocate memory and free memory for data. If the memory is not freed, it could be claimed but cannot be used. This leads to memory leak.

### Early forms of automated memory management
* Destructors
	Destructors will automatically called when objects are not in scope, but not efficient when objects are shared during multi-threading.
* Reference counting via shared pointers
	When the count of references to an object reaches 0, the object can be safely reclaimed. This is done by the shared pointer. 

	GCRootA---> OB1(1)--> OB5(3)  
	GCRootB---> OB2(1)<-- OB4(1)  
	ob(2)  
	ob(1)<-- ob(2)  
	ob1(1)-->ob2(1)-  
	|_______<______|  

	Here GCRoots indicate the objects they point to are still in use. OB indicates live objects and the reference counts. ob refers to objects that are not explicitly used by any objects. So, the ob objects are garbage.

	Challenge : Although ob1 and ob2 are not used, they form an isolated cycle of detached objects that will never have a reference count of 0 and will not be considered as a garbage.

## Mark and Sweep
JVM specifically defines what constitutes reachability of an object. These objects form GC roots - 
* Local Variables
* Active threads
* Static fields
* JNI references

So the method used by JVM to track down all live(reachable) objectd and ensure memory claimed by non-reachable object can be reused is called Mark and Sweep algorithm.
Mark - Walk thru all reachable objects starting from GC roots and keep a ledger in native memory about all such objects
Sweep - Ensure memory addresses held by non-reachable objects can be reused by next allocation

This means there are no more memory leaks i.e even detached cyclic non-reachable objects can be claimed.
Disadv : Application threads need to be stopped for the collection to happen since you cannot count references if they keep changing while counting. This means the app is temporarily stopped so JVM can perform this activity - Stop The World pause.

## More practical nuances
1. Fragmenting and Compacting
* Sweepig ensures the JVM can reclaim memory addresses possessed by non-reachable objects can be reused. Hoever, this will eventually lead to fragmentation. This brings 2 challenges 
** Write ops become expensive inorder to find next block of sufficient contigious size
** If it cannot find contigious space, then allocation error will occur when create space for newly created object.

This highlights the importance of memory defragmentation

## General Hypothesis
1. More objects generated by application, the longer it takes to collect all garbage.
2. Most of the objects become unused quickly. (Die Young)
3. The ones that are needed survive for a long time (Live forever)

This forms the foundation for Weak Generational Hypothesis. Memory is divided into Young Generation and Old Generation (Tenured).
Adv : Several algos that can leverage this division to improve GC
Dis : JVM behaves poorly for objects with medium life expectancy.

## General Memory pools

-------------------Young---------------|----------Tenured------------|-----PermGen--------|  
-----Eden-----------|---S1---|--S2-----|-----------------------------|--------------------|  
--1.TLAB--2.TLAB--CA|--------|---------|-----------------------------|--------------------|  

### Eden
* Area of memory where freshly/newly created objects reside
* Divided further into Thread-Local-Allocation-Buffer. This is to ensure all objects needed by a single thread exist in one buffer and helps avoid sync cost with other threads. 
* If objects are shared among multiple threads, they reside in Common Area. If objects wont fit in any TLAB, they also reside in Common Area.
* If there is no room in the Common Area, then a GC process in YoungGen is triggered to free up space.
* The GC walks through the live objects and marks them.
* After the mark is complete, the live objects in Eden are copied (not moved) to one of the Survivor space. This frees up Eden for reallocation of new objects.  [ Mark and Copy ]
* If the GC does not result in enough free space to allocate for a new object inside Eden, then the object is allocated in OldGen/Tenured.

### Surivior spaces
* "From" and "To" spaces, where one of the two is always empty.
* When the next GC in YoungGen happens, the empty survivior will have residents - all live objects from both Eden and "from" survivor are written to the "to" survivor.
* Roles are then switched.
* The process of copying live objects between two survivor spaces continues several cycles until the objects have "matured" or "tenured"
* To determine whether the objects have matured, GC tracks the number of collections a particular object survived i.e with each GC in YoungGen, such object's age gets incremented. When age exceeds a tenuring threshold, they get copied to OldGen space.
** Tenuring Threshold can be dynamically set by JVM   

	XX:+MaxTenuringThreshold=0. 

	0=> immediate promotion from Eden to OldGen without copying it to Survivior space. Default, 15 GC cycles.
* Promotion may also happen if size of survivor unable to hold all live objects.


### Old Generation
* Significantly larger and contains objects that are expected to live much longer.
* GC happens less frequently
* There is no Mark and Copy since objects are expected to be alive in OldGen. But, moved around to avoid fragmentation.


### PermGen
* Area where metadata such as classes were stored. 
* Uncontrolled area before Java 8 and often resulted in java.lang.OutOfMemoryError: PermGen space
* Solution : increase the PermGen size
  
  java -XX:MaxPermSize=256m com.mycompany.MyApplication


### MetaSpace
* Class definitions in Java 8 are now stored in native memory and does not interfere with regular heap objects. This means we no longer run into OOM Errors, but not shielded from native memory allocation errors. To protect, we can limit the metaspace size using - 
  
  java -XX:MaxMetaspaceSize=256m com.mycompany.MyApplication


## Minor GC, Major GC and Full GC

The real crux, irrespective of the type of GC, dod it stop all threads or able to progress concurrently?

### Minor GC
* Collecting garbage from YounGen is MinorGC i.e cleans the YoungGen.
* Always triggered when JVM is unable to allocate space for new objecs i.e when Eden gets full. High Allocation rate of new objects, implies frequent Minor GC.
* Tenured Gen is effectively ignored
* Minor GC is STW event.
** Length of pause is negligible if most of the objects in Eden end up being garbage and never copied to Survivor/OldGen.
** If most of the objects are not eligible for collection, then Minor GC pauses start taking considerable time.

### Major GC
* Cleaning up the OldGen

### Final GC
* Cleanup entire Heap i.e both YoungGen and OldGen






